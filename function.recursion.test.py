# -*- coding: utf-8 -*-
# function.recursion.test.py

def short_story():
    print("У попа была собака, он ее любил.")
    print("Она съела кусок мяса, он ее убил,")
    print("В землю закопал и надпись написал:")
    short_story()


# факториалом числа, например, 5 является произведение всех натуральных (целых) чисел от 1 до 5. То есть, 1 * 2 * 3 * 4 * 5 Рекурсивная функция вычисления факториала на языке Python будет выглядеть так:

def fact(num):
    if num == 0: 
        return 1 # По договоренности факториал нуля равен единице
    else:
        return num * fact(num - 1) # возвращаем результат произведения num и результата возвращенного функцией fact(num - 1)

# Хорошо известно, что 0!=1, 1!=1. А как вычислить величину n! для большого n? Если бы мы могли вычислить величину (n-1)!, то тогда мы легко вычислим n!, поскольку n!=n⋅(n-1)!. Но как вычислить (n-1)!? Если бы мы вычислили (n-2)!, то мы сможем вычисли и (n-1)!=(n-1)⋅(n-2)!. А как вычислить (n-2)!? Если бы... В конце концов, мы дойдем до величины 0!, которая равна 1. Таким образом, для вычисления факториала мы можем использовать значение факториала для меньшего числа.

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)

print(factorial(5))

# ВЫЧИСЛЕНИЕ СУММЫ НАТУРАЛЬНЫХ ЧИСЕЛ ОТ 1 ДО N
# Если n==1, то сумма равна 1. Иначе сумма чисел от 1 до n равна сумме чисел от 1 до n−1, которую можно вычислить при помощи рекурсии плюс число n.

def sum(n):
    if n == 1:
        return 1
    else:
        return n + sum(n - 1)

# ПРОВЕРКА СТРОКИ НА ПАЛИНДРОМНОСТЬ
# Строка является палиндромом, если она одинаково читается как справа налево, так и слева направо. Напишем функцию IsPalindrome, которая возвращает значение типа bool в зависимости от того, является ли строка палиндромом. Крайнее значение — пустая строка или строка из одного символа всегда палиндром. Рекурсивный переход — строка является палиндромом, если у нее совпадают первый и последний символ, а также строка, полученная удалением первого и последнего символа является палиндромом.

def IsPalindrome(S):
    if len(S) <= 1:
        return True
    else:
        return S[0] == S[-1] and IsPalindrome(S[1:-1])

# СУММИРОВАНИЕ СПИСКА
# Дан список чисел, необходимо просуммировать его. Крайний случай — пустой список, сумма чисел в нем равна 0. Иначе нужно вычислить сумму чисел в срезе списка без одного элемента и добавить значение этого элемента.

def Sum(A):
    if len(A) == 0:
        return 0
    else:
        return Sum(A[:-1]) + A[-1]

# НАИБОЛЬШЕЕ ЗНАЧЕНИЕ В СПИСКЕ
# Дан список чисел, необходимо найти наибольшее значение в нем. Крайний случай — список из одного элемента, наибольшее значение в нем равно единственному элементу. Иначе нужно вычислить наибольшее значение в срезе списка без одного элемента и взять максимум из этого числа и значения этого элемента.

def Max(A):
    if len(A) == 1:
        return A[0]
    else:
        return max(Max(A[:-1]), A[-1])

# ЧИСЛА ФИБОНАЧЧИ
# Последовательность Фибоначчи задана так: F0=0, F1=1, при n>1 число Фибоначчи с номером n вычисляется как Fn=Fn−1+Fn−2. Для рекурсивного вычисления чисел Фибоначчи достаточно аккуратно запрограммировать эти соотношения:

def Fib(n):
    if n <= 1:
        return n
    else:
        return Fib(n - 1) + Fib(n - 2)
# БЫСТРОЕ ВОЗВЕДЕНИЕ В СТЕПЕНЬ
# Одним из полезных применений рекурсии является алгоритм быстрого возведения в степень. Если вычислять степень числа an при помощи простого цикла, то понадобится n−1 умножение. Но можно использовать рекуррентные соотношения:

# an=an−1×a, при нечетном n
# an=(an/2)2, при четном n.
# # Это позволяет записать алгоритм, который будет выполнять не более, чем 2∗log2n умножений:

def power(a, n):
    if n == 0:
        return 1
    elif n % 2 == 1:
        return power(a, n - 1) * a
    else:
        return power(a, n // 2) ** 2

# ХАНОЙСКИЕ БАШНИ
# Другой классической задачей, решаемой при помощи рекурсии, является задача о Ханойских башнях. Головоломка “Ханойские башни” состоит из трех стержней, пронумерованных числами 1, 2, 3. На стержень 1 надета пирамидка из n дисков различного диаметра в порядке возрастания диаметра. Диски можно перекладывать с одного стержня на другой строго по одному, при этом диск нельзя класть на диск меньшего диаметра. Необходимо переложить всю пирамидку со стержня 1 на стержень 3 за минимальное число перекладываний. Необходимо написать программу, которая для данного числа дисков n печатает последовательность перекладываний, необходимую для решения головоломки. Сначала нужно подумать, как переложить пирамидку из n дисков с одного стержня на другой. Для этого нужно прежде всего перенести самый большой диск. Но чтобы перенести этот диск нужно всю пирамидку без этого диска, то есть пирамидку из n−1 диска перенести на третий стержень, затем перенести один самый большой диск, затем перенести пирамидку из n−1 диска на тот стержень, на который переместили самый большой диск. Напишем рекурсивную функцию move(n, start, finish), которая печатает последовательность перекладываний, необходимых для перемещения пирамидки из n дисков со стержня номер start на стержень номер finish. Простой случай — n==1, в этом случае рекурсия не нужна и нужно просто переместить один диск.

def move(n, start, finish):
    if n == 1:
        print("Перенести диск 1 со стержня", start, "на стержень", finish)
    else:
        temp = 6 - start - finish # Вспомогательный hook
        move(n - 1, start, temp)
        print("Перенести диск", n, "со стержня", start, "на стержень", finish)
        move(n - 1, temp, finish)


# Для решения головоломки из 10 дисков вызываем так:
move(10, 1, 3)

# Решение можно сделать проще, если понять, что крайний случай — это случай n==0, в этом случае для перемещения пирамидки из 0 дисков… просто ничего не нужно делать!

def moveh(n, start, finish):
    if n > 0:
        temp = 6 - start - finish # Вспомогательный hook
        move(n - 1, start, temp)
        print("Перенести диск", n, "со стержня", start, "на стержень", finish)
        move(n - 1, temp, finish)

# ОГРАНИЧЕНИЕ НА ГЛУБИНУ РЕКУРСИИ
# По умолчанию глубина рекурсии в языке Питон ограничена 1000 вызовов. Это ограничение можно поднять при помощи функции setrecursionlimit из модуля system. Например, чтобы увеличить возможную глубину рекурсии до 10000 нужно в начале программы выполнить две инструкции:

# import sys
# sys.setrecursionlimit(10000)
