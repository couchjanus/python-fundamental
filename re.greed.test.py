# -*- coding: utf-8 -*-
# re.greed.test.py

import re

# При повторении в РВ, таком как a*, результирующее действие съедает настолько большую часть шаблона, насколько это возможно. 
# На этом часто обжигаются те, кто хочет найти пару симметричных определителей, таких как угловые скобки <>, окружающие HTML-теги. 
# Наивный подход к шаблону сопоставления тега HTML не будет работать из-за «жадного» характера .*:

s = '<html><head><title>Title</title>'
len(s)

print(re.match('<.*>', s).span())

print(re.match('<.*>', s).group())

# not greedy

# В таком случае, решение заключается в использовании нежадных определителей *?, +?, ?? или {m,n}?, которые сопоставляют так мало текста, как это возможно. 

# В примере выше, будет выбран первый символ '>' после '<', и только, если не получится, движок будет продолжать попытки найти символ '>' на следующей позиции, в зависимости от того, как длинно имя тега. Это дает нужный результат:

print(re.match('<.*?>', s).group())

heading  = r'<h1>TITLE</h1>'
print(re.match(r'<.*>', heading).group())

heading  = r'<h1>TITLE</h1>'
print(re.match(r'<.*?>', heading).group())

# Для таких задач лучше использовать модули HTML или XML парсеров.)
